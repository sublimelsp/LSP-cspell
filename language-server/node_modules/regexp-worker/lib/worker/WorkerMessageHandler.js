"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerMessageHandler = exports.LogLevel = exports.createHandler = void 0;
const util_1 = require("util");
const errors_1 = require("../helpers/errors");
const procedure_1 = require("../Procedures/procedure");
const procedures_1 = require("../Procedures/procedures");
const MessagePort_1 = require("./MessagePort");
function createHandler(port) {
    return new WorkerMessageHandler(port);
}
exports.createHandler = createHandler;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["LogLevelNone"] = 0] = "LogLevelNone";
    LogLevel[LogLevel["LogLevelError"] = 1] = "LogLevelError";
    LogLevel[LogLevel["LogLevelWarn"] = 2] = "LogLevelWarn";
    LogLevel[LogLevel["LogLevelInfo"] = 3] = "LogLevelInfo";
    LogLevel[LogLevel["LogLevelDebug"] = 4] = "LogLevelDebug";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
class WorkerMessageHandler {
    constructor(port) {
        this.port = port;
        this.logLevel = LogLevel.LogLevelError;
        this.listener = (v) => this.listenerMessage(v);
        port.on('message', this.listener);
    }
    dispose() {
        this.port.off('message', this.listener);
        this.port = MessagePort_1.nullPort;
    }
    post(msg) {
        this.log(LogLevel.LogLevelDebug, 'Post: ' + JSON.stringify(msg));
        this.port.postMessage(msg);
    }
    log(level, message, ...rest) {
        if (level > this.logLevel)
            return;
        switch (level) {
            case LogLevel.LogLevelError:
                console.error(message, ...rest);
                break;
            case LogLevel.LogLevelWarn:
                console.warn(message, ...rest);
                break;
            default:
                console.log(message, ...rest);
        }
    }
    listenerMessage(value) {
        this.log(LogLevel.LogLevelDebug, `message: ${JSON.stringify(value)}`);
        if (!(0, procedure_1.isRequest)(value)) {
            const msg = `Badly formed Request: ${JSON.stringify(value)}`;
            this.log(LogLevel.LogLevelError, msg);
            this.post((0, procedure_1.createErrorResponse)(value, msg));
            return;
        }
        const request = value;
        for (const proc of procedures_1.procedures) {
            try {
                const response = proc(request);
                if (response !== undefined) {
                    Promise.resolve(response)
                        .catch((reason) => (0, procedure_1.createErrorResponse)(request, reason.toString(), reason))
                        .then((r) => this.post(r));
                    return;
                }
            }
            catch (e) {
                const msg = (0, errors_1.isError)(e) ? e.message : (0, util_1.format)(e);
                this.post((0, procedure_1.createErrorResponse)(request, msg, (0, errors_1.isError)(e) ? e : undefined));
                return;
            }
        }
        this.log(LogLevel.LogLevelWarn, `Unhandled Request "${value.requestType}"`);
        this.post((0, procedure_1.createErrorResponse)(request, 'Unhandled Request'));
    }
}
exports.WorkerMessageHandler = WorkerMessageHandler;
//# sourceMappingURL=WorkerMessageHandler.js.map