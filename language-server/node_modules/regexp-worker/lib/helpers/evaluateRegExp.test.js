"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const evaluateRegExp_1 = require("./evaluateRegExp");
const fs = require("fs");
const Path = require("path");
describe('EvaluateRegExp', () => {
    const text = `
This is a bit of text for everyone to read.

How about this?

Some more cool text.

Numbers: 1, 2, 3, 4, 1000, -55.0, 1.34e2
const x2 = 'hello';
`;
    const code = fs.readFileSync(Path.join(__filename), 'utf8');
    const w = (result) => resultsToTexts(result.matches);
    test('evaluateRegExp', () => {
        const words = w((0, evaluateRegExp_1.execRegExp)(/\w+/g, text));
        expect(words).toEqual(text
            .split(/\b/g)
            .map((s) => s.replace(/[^\w]/g, ''))
            .filter(notEmpty));
        const wordBreaks = (0, evaluateRegExp_1.execRegExp)(/\b/g, text).matches;
        expect(wordBreaks.map((r) => r.index).slice(0, 5)).toEqual([1, 5, 6, 8, 9]);
        const startOfWords = (0, evaluateRegExp_1.execRegExp)(/\b(?=\w)/g, text).matches;
        expect(startOfWords.map((r) => r.index).slice(0, 5)).toEqual([1, 6, 9, 11, 15]);
        const singleWord = (0, evaluateRegExp_1.execRegExp)(/about/, text);
        expect(w(singleWord)).toEqual(['about']);
    });
    test('toRegExp', () => {
        expect((0, evaluateRegExp_1.toRegExp)(/./g).toString()).toBe(/./g.toString());
        expect((0, evaluateRegExp_1.toRegExp)(/./g.toString())).toEqual(/./g);
        expect((0, evaluateRegExp_1.toRegExp)('hello')).toEqual(/hello/);
        expect((0, evaluateRegExp_1.toRegExp)('hello.')).toEqual(/hello./);
        expect((0, evaluateRegExp_1.toRegExp)('hello*')).toEqual(/hello*/);
    });
    test('execRegExpMatrix', () => {
        const empty = (0, evaluateRegExp_1.execRegExpMatrix)([], []);
        expect(empty).toEqual(expect.objectContaining({
            elapsedTimeMs: expect.any(Number),
            matrix: expect.arrayContaining([]),
        }));
        const result = (0, evaluateRegExp_1.execRegExpMatrix)([/\bt\w+/g, /\d+/g, /\execRegExpMatrix.*/], [text, code]);
        expect(result.elapsedTimeMs).toBeGreaterThan(0);
        expect(result.matrix).toEqual(expect.any(Array));
        expect(result.matrix).toHaveLength(3);
        expect(result.matrix[0].regExp).toEqual(/\bt\w+/g);
        expect(result.matrix[2].results).toHaveLength(2);
        expect(result.matrix[2].results[1].matches).toHaveLength(1);
    });
    test('execRegExpArray', () => {
        const r = (0, evaluateRegExp_1.execRegExpArray)([/\w+/g], text);
        expect(r.results.map((r) => r.matches).map(resultsToTexts)).toEqual([w((0, evaluateRegExp_1.execRegExp)(/\w+/g, text))]);
    });
    test('matchRegExp', () => {
        const r = (0, evaluateRegExp_1.matchRegExp)(text, /\w+/g);
        const words = [...flatRangesToTexts(r.ranges, text)];
        expect(words).toEqual(text
            .split(/\b/g)
            .map((s) => s.replace(/[^\w]/g, ''))
            .filter(notEmpty));
        expect(r.elapsedTimeMs).toBeGreaterThan(0);
        expect(r.elapsedTimeMs).toBeLessThan(100);
    });
    test('matchRegExpArray', () => {
        const regExps = [/\w+/g, /\d+/g];
        const r = (0, evaluateRegExp_1.matchRegExpArray)(text, regExps);
        expect(r.elapsedTimeMs).toBeGreaterThan(0);
        expect(r.elapsedTimeMs).toBeLessThan(100);
        expect(r.elapsedTimeMs).toBeGreaterThan(r.results.map((a) => a.elapsedTimeMs).reduce((a, b) => a + b, 0));
        for (let i = 0; i < r.results.length; ++i) {
            const result = r.results[i];
            const regexp = regExps[i];
            expect(result.elapsedTimeMs).toBeGreaterThan(0);
            expect(result.elapsedTimeMs).toBeLessThan(100);
            const expectedWords = w((0, evaluateRegExp_1.execRegExp)(regexp, text));
            const words = [...flatRangesToTexts(result.ranges, text)];
            expect(words).toEqual(expectedWords);
        }
    });
});
function notEmpty(v) {
    return !!v;
}
function regExpExecArrayToText(match) {
    return match[0];
}
function resultsToTexts(matches) {
    return matches.map(regExpExecArrayToText);
}
function* flatRangesToTexts(ranges, text) {
    for (const [start, end] of (0, evaluateRegExp_1.flatRangesToRanges)(ranges)) {
        yield text.slice(start, end);
    }
}
//# sourceMappingURL=evaluateRegExp.test.js.map