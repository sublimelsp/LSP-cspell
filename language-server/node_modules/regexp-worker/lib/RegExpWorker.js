"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchRegExpArrayResult = exports.MatchRegExpResult = exports.execRegExpMatrixOnWorker = exports.execRegExpOnWorker = exports.RegExpWorker = exports.toRegExp = void 0;
const evaluateRegExp_1 = require("./helpers/evaluateRegExp");
const scheduler_1 = require("./scheduler");
const Procedures_1 = require("./Procedures");
const procMatchRegExp_1 = require("./Procedures/procMatchRegExp");
const procMatchRegExpArray_1 = require("./Procedures/procMatchRegExpArray");
var evaluateRegExp_2 = require("./helpers/evaluateRegExp");
Object.defineProperty(exports, "toRegExp", { enumerable: true, get: function () { return evaluateRegExp_2.toRegExp; } });
class RegExpWorker {
    constructor(timeoutMs) {
        this.dispose = () => this._dispose();
        this.scheduler = new scheduler_1.Scheduler(timeoutMs);
    }
    execRegExp(regExp, text, timeLimitMs) {
        const req = (0, Procedures_1.createRequestExecRegExp)({ regexp: regExp, text });
        return this.makeRequest(req, timeLimitMs);
    }
    execRegExpMatrix(regExpArray, textArray, timeLimitMs) {
        const req = (0, Procedures_1.createRequestExecRegExpMatrix)({ regExpArray, textArray });
        return this.makeRequest(req, timeLimitMs);
    }
    matchRegExp(text, regExp, timeLimitMs) {
        const req = (0, procMatchRegExp_1.createRequestMatchRegExp)({ regexp: regExp, text });
        return this.makeRequest(req, timeLimitMs).then(MatchRegExpResult.create);
    }
    matchRegExpArray(text, regExp, timeLimitMs) {
        const req = (0, procMatchRegExpArray_1.createRequestMatchRegExpArray)({ regexps: regExp, text });
        return this.makeRequest(req, timeLimitMs).then(MatchRegExpArrayResult.create);
    }
    makeRequest(req, timeLimitMs) {
        return this.scheduler.scheduleRequest(req, timeLimitMs).then(extractResult, timeoutRejection);
    }
    /**
     * Shuts down the background Worker and rejects any pending scheduled items.
     */
    _dispose() {
        return this.scheduler.dispose().then();
    }
    set timeout(timeoutMs) {
        this.scheduler.executionTimeLimitMs = timeoutMs;
    }
    get timeout() {
        return this.scheduler.executionTimeLimitMs;
    }
}
exports.RegExpWorker = RegExpWorker;
function extractResult(response) {
    return response.data;
}
function timeoutRejection(e) {
    if (!e || !e.message || !e.elapsedTimeMs)
        return Promise.reject(e);
    return Promise.reject({
        message: e.message,
        elapsedTimeMs: e.elapsedTimeMs,
    });
}
function execRegExpOnWorker(regExp, text, timeLimitMs) {
    const worker = new RegExpWorker();
    return worker.execRegExp(regExp, text, timeLimitMs).finally(worker.dispose);
}
exports.execRegExpOnWorker = execRegExpOnWorker;
function execRegExpMatrixOnWorker(regExpArray, textArray, timeLimitMs) {
    const worker = new RegExpWorker();
    return worker.execRegExpMatrix(regExpArray, textArray, timeLimitMs).finally(worker.dispose);
}
exports.execRegExpMatrixOnWorker = execRegExpMatrixOnWorker;
class MatchRegExpResult {
    constructor(elapsedTimeMs, raw_ranges) {
        this.elapsedTimeMs = elapsedTimeMs;
        this.raw_ranges = raw_ranges;
    }
    /**
     * The range tuples that matched the full regular expression.
     * Each tuple is: [startIndex, endIndex]
     */
    get ranges() {
        return (0, evaluateRegExp_1.flatRangesToRanges)(this.raw_ranges);
    }
    static create(res) {
        return new MatchRegExpResult(res.elapsedTimeMs, res.ranges);
    }
}
exports.MatchRegExpResult = MatchRegExpResult;
class MatchRegExpArrayResult {
    constructor(elapsedTimeMs, results) {
        this.elapsedTimeMs = elapsedTimeMs;
        this.results = results;
    }
    static create(res) {
        return new MatchRegExpArrayResult(res.elapsedTimeMs, res.results.map(MatchRegExpResult.create));
    }
}
exports.MatchRegExpArrayResult = MatchRegExpArrayResult;
//# sourceMappingURL=RegExpWorker.js.map