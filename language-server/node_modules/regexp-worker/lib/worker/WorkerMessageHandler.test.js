"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WorkerMessageHandler_1 = require("./WorkerMessageHandler");
const procEcho_1 = require("../Procedures/procEcho");
const procedure_1 = require("../Procedures/procedure");
const uniqueId_1 = require("../Procedures/uniqueId");
const procGenError_1 = require("../Procedures/procGenError");
const consoleLog = (console.log = jest.fn());
const consoleWarn = (console.warn = jest.fn());
const consoleError = (console.error = jest.fn());
describe('WorkerMessageHandler', () => {
    beforeEach(() => {
        jest.resetAllMocks();
    });
    test('createHandler', () => {
        const port = mockMessagePort();
        const handler = (0, WorkerMessageHandler_1.createHandler)(port);
        expect(port.registeredCallbacks.size).toBe(1);
        handler.dispose();
        expect(port.registeredCallbacks.size).toBe(0);
        port.close();
        expect(port.on).toBeCalledWith('message', expect.any(Function));
        expect(port.off).toBeCalledWith('message', expect.any(Function));
        expect(consoleLog).not.toBeCalled();
        expect(consoleWarn).not.toBeCalled();
        expect(consoleError).not.toBeCalled();
    });
    test('Echo', async () => {
        const port = mockMessagePort();
        const messagesIterator = port.messagesAsync[Symbol.asyncIterator]();
        const handler = (0, WorkerMessageHandler_1.createHandler)(port);
        port.sendMessage((0, procEcho_1.createRequestEcho)('Hello'));
        const response = await messagesIterator.next();
        expect(response.value).toEqual(expect.objectContaining({
            data: 'Hello',
        }));
        handler.dispose();
        port.close();
    });
    test('Echo using Iterator', async () => {
        const port = mockMessagePort();
        const handler = (0, WorkerMessageHandler_1.createHandler)(port);
        port.sendMessage((0, procEcho_1.createRequestEcho)('Hello'));
        const response = await port.next();
        expect(response.value).toEqual(expect.objectContaining({
            data: 'Hello',
        }));
        handler.dispose();
        port.close();
    });
    test('Unhandled Request', async () => {
        const port = mockMessagePort();
        const messagesIterator = port.messagesAsync[Symbol.asyncIterator]();
        const handler = (0, WorkerMessageHandler_1.createHandler)(port);
        handler.logLevel = WorkerMessageHandler_1.LogLevel.LogLevelDebug;
        port.sendMessage((0, procedure_1.createRequest)('Test Unknown', {}));
        const response = await messagesIterator.next();
        expect(response.value).toEqual(expect.objectContaining({
            responseType: 'Error',
            data: {
                message: 'Unhandled Request',
                requestType: 'Test Unknown',
            },
        }));
        handler.dispose();
        port.close();
        expect(consoleLog).toBeCalled();
        expect(consoleWarn).toBeCalled();
        expect(consoleError).not.toBeCalled();
    });
    test('Bad Request', async () => {
        const port = mockMessagePort();
        const messagesIterator = port.messagesAsync[Symbol.asyncIterator]();
        const handler = (0, WorkerMessageHandler_1.createHandler)(port);
        handler.logLevel = WorkerMessageHandler_1.LogLevel.LogLevelDebug;
        port.sendMessage('Bad Request');
        const response = await messagesIterator.next();
        expect(response.value).toEqual(expect.objectContaining({
            responseType: 'Error',
            id: uniqueId_1.NullID,
            data: {
                message: expect.stringContaining('Badly formed Request'),
                requestType: undefined,
            },
        }));
        handler.dispose();
        port.close();
        expect(consoleLog).toBeCalled();
        expect(consoleWarn).not.toBeCalled();
        expect(consoleError).toBeCalled();
    });
    test('Generating Errors', async () => {
        const port = mockMessagePort();
        const handler = (0, WorkerMessageHandler_1.createHandler)(port);
        const requestThrow = (0, procGenError_1.createRequestGenError)('Throw');
        port.sendMessage(requestThrow);
        const responseThrow = await port.next();
        expect(responseThrow.value).toEqual(expect.objectContaining({
            id: requestThrow.id,
            responseType: 'Error',
            data: expect.objectContaining({
                message: 'Error Thrown',
            }),
        }));
        const requestReject = (0, procGenError_1.createRequestGenError)('reject');
        port.sendMessage(requestReject);
        const responseReject = await port.next();
        expect(responseReject.value).toEqual(expect.objectContaining({
            id: requestReject.id,
            responseType: 'Error',
            data: expect.objectContaining({
                message: 'Error: Reject',
            }),
        }));
        handler.dispose();
        port.close();
    });
});
function mockMessagePort() {
    let resolveAsync;
    const messages = [];
    const messagesAsync = callbackIterable((resolve) => {
        resolveAsync = resolve;
    });
    function postMessage(value) {
        messages.push(value);
        resolveAsync === null || resolveAsync === void 0 ? void 0 : resolveAsync(Promise.resolve({ value }));
    }
    const registeredCallbacks = new Map();
    function on(event, callback) {
        var _a;
        const callbacks = (_a = registeredCallbacks.get(event)) !== null && _a !== void 0 ? _a : new Set();
        callbacks.add(callback);
        registeredCallbacks.set(event, callbacks);
        return port;
    }
    function off(event, callback) {
        const callbacks = registeredCallbacks.get(event);
        if (!callbacks || !callbacks.has(callback))
            throw new Error(`Unknown Function "${event}"`);
        callbacks.delete(callback);
        if (!callbacks.size) {
            registeredCallbacks.delete(event);
        }
        return port;
    }
    function sendMessage(v) {
        const callbacks = registeredCallbacks.get('message');
        if (!callbacks)
            throw new Error('No listeners on "message"');
        for (const call of callbacks) {
            call(v);
        }
    }
    function close() {
        resolveAsync === null || resolveAsync === void 0 ? void 0 : resolveAsync(Promise.resolve({ done: true, value: undefined }));
    }
    const mockOn = jest.fn(on);
    const mockOff = jest.fn(off);
    const iterator = messagesAsync[Symbol.asyncIterator]();
    const next = () => iterator.next();
    const port = {
        messages,
        messagesAsync,
        registeredCallbacks,
        sendMessage,
        postMessage: jest.fn(postMessage),
        on: mockOn,
        off: mockOff,
        next,
        close,
    };
    return port;
}
function callbackIterable(callBack) {
    const buffer = [];
    let done = false;
    let pending;
    callBack((next) => {
        buffer.push(next);
        trigger();
    });
    function trigger() {
        const resolve = pending;
        pending = undefined;
        if (resolve) {
            resolve(next());
        }
    }
    async function next() {
        if (done)
            return { done, value: undefined };
        if (buffer.length) {
            const v = await buffer.shift();
            done = !!v.done;
            return v;
        }
        return new Promise((resolve) => {
            pending = resolve;
        });
    }
    const iterable = {
        [Symbol.asyncIterator]: () => ({ next }),
    };
    return iterable;
}
//# sourceMappingURL=WorkerMessageHandler.test.js.map